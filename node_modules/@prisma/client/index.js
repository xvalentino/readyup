
Object.defineProperty(exports, "__esModule", { value: true });

const {
  DMMF,
  DMMFClass,
  deepGet,
  deepSet,
  makeDocument,
  Engine,
  debugLib,
  transformDocument,
  chalk,
  printStack,
  mergeBy,
  unpack,
  stripAnsi,
  parseDotenv,
  Dataloader,
  PrismaClientKnownRequestError,
  PrismaClientUnknownRequestError,
  PrismaClientRustPanicError,
  PrismaClientInitializationError,
  PrismaClientValidationError,
  lowerCase
} = require('./runtime')

/**
 * Query Engine version: latest
 */

const path = require('path')
const fs = require('fs')

const debug = debugLib('prisma-client')

exports.PrismaClientKnownRequestError = PrismaClientKnownRequestError;
exports.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError;
exports.PrismaClientRustPanicError = PrismaClientRustPanicError;
exports.PrismaClientInitializationError = PrismaClientInitializationError;
exports.PrismaClientValidationError = PrismaClientValidationError;

class PrismaClientFetcher {
  constructor(prisma, enableDebug = false, hooks) {
    this.prisma = prisma;
    this.debug = enableDebug;
    this.hooks = hooks;
    this.dataloader = new Dataloader(async (requests) => {
      // TODO: More elaborate logic to only batch certain queries together
      // We should e.g. make sure, that findOne queries are batched together
      await this.prisma.connect();
      const queries = requests.map(r => String(r.document))
      debug('Requests:')
      debug(queries)
      const results = await this.prisma.engine.request(queries)
      debug('Results:')
      debug(results)
      return results
    })
  }
  async request({ document, dataPath = [], rootField, typeName, isList, callsite, collectTimestamps, clientMethod }) {
    if (this.hooks && this.hooks.beforeRequest) {
      const query = String(document);
      this.hooks.beforeRequest({ query, path: dataPath, rootField, typeName, document });
    }
    try {
      collectTimestamps && collectTimestamps.record("Pre-prismaClientConnect");
      collectTimestamps && collectTimestamps.record("Post-prismaClientConnect");
      collectTimestamps && collectTimestamps.record("Pre-engine_request");
      const result = await this.dataloader.request({ document });
      collectTimestamps && collectTimestamps.record("Post-engine_request");
      collectTimestamps && collectTimestamps.record("Pre-unpack");
      const unpackResult = this.unpack(document, result, dataPath, rootField, isList);
      collectTimestamps && collectTimestamps.record("Post-unpack");
      return unpackResult;
    } catch (e) {
      debug(e.stack);
      if (callsite) {
        const { stack } = printStack({
          callsite,
          originalMethod: clientMethod,
          onUs: e.isPanic
        });
        const message = stack + e.message;
        if (e.code) {
          throw new PrismaClientKnownRequestError(this.sanitizeMessage(message), e.code, e.meta);
        }
        if (e instanceof PrismaClientUnknownRequestError) {
          throw new PrismaClientUnknownRequestError(this.sanitizeMessage(message));
        } else if (e instanceof PrismaClientInitializationError) {
          throw new PrismaClientInitializationError(this.sanitizeMessage(message));
        } else if (e instanceof PrismaClientRustPanicError) {
          throw new PrismaClientRustPanicError(this.sanitizeMessage(message));
        }
      } else {
        if (e.code) {
          throw new PrismaClientKnownRequestError(this.sanitizeMessage(e.message), e.code, e.meta);
        }
        if (e.isPanic) {
          throw new PrismaClientRustPanicError(e.message);
        } else {
          if (e instanceof PrismaClientUnknownRequestError) {
            throw new PrismaClientUnknownRequestError(this.sanitizeMessage(message));
          } else if (e instanceof PrismaClientInitializationError) {
            throw new PrismaClientInitializationError(this.sanitizeMessage(message));
          } else if (e instanceof PrismaClientRustPanicError) {
            throw new PrismaClientRustPanicError(this.sanitizeMessage(message));
          }
        }
      }
    }
  }
  sanitizeMessage(message) {
    if (this.prisma.errorFormat && this.prisma.errorFormat !== 'pretty') {
      return stripAnsi(message);
    }
    return message;
  }
  unpack(document, data, path, rootField, isList) {
    if (data.data) {
      data = data.data
    }
    const getPath = [];
    if (rootField) {
      getPath.push(rootField);
    }
    getPath.push(...path.filter(p => p !== 'select' && p !== 'include'));
    return unpack({ document, data, path: getPath });
  }
}

class CollectTimestamps {
  constructor(startName) {
    this.records = [];
    this.start = undefined;
    this.additionalResults = {};
    this.start = { name: startName, value: process.hrtime() };
  }
  record(name) {
    this.records.push({ name, value: process.hrtime() });
  }
  elapsed(start, end) {
    const diff = [end[0] - start[0], end[1] - start[1]];
    const nanoseconds = (diff[0] * 1e9) + diff[1];
    const milliseconds = nanoseconds / 1e6;
    return milliseconds;
  }
  addResults(results) {
    Object.assign(this.additionalResults, results);
  }
  getResults() {
    const results = this.records.reduce((acc, record) => {
      const name = record.name.split('-')[1];
      if (acc[name]) {
        acc[name] = this.elapsed(acc[name], record.value);
      }
      else {
        acc[name] = record.value;
      }
      return acc;
    }, {});
    Object.assign(results, {
      total: this.elapsed(this.start.value, this.records[this.records.length - 1].value),
      ...this.additionalResults
    });
    return results;
  }
}


/**
 * Build tool annotations
 * In order to make `ncc` and `node-file-trace` happy.
**/

path.join(__dirname, 'runtime/query-engine-darwin');

/**
 * Client
**/

// tested in getLogLevel.test.ts
function getLogLevel(log) {
    return log.reduce((acc, curr) => {
        const currentLevel = typeof curr === 'string' ? curr : curr.level;
        if (currentLevel === 'query') {
            return acc;
        }
        if (!acc) {
            return currentLevel;
        }
        if (curr === 'info' || acc === 'info') {
            // info always has precedence
            return 'info';
        }
        return currentLevel;
    }, undefined);
}
exports.getLogLevel = getLogLevel;

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Reminders
 * const reminders = await prisma.reminder.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://github.com/prisma/prisma2/blob/master/docs/prisma-client-js/api.md).
 */
class PrismaClient {
/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Reminders
 * const reminders = await prisma.reminder.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://github.com/prisma/prisma2/blob/master/docs/prisma-client-js/api.md).
 */
  constructor(optionsArg) {
    const options = optionsArg || {}
    const internal = options.__internal || {}

    const useDebug = internal.debug === true
    if (useDebug) {
      debugLib.enable('prisma-client')
    }

    // datamodel = datamodel without datasources + printed datasources

    const predefinedDatasources = []

    const inputDatasources = Object.entries(options.datasources || {}).map(([name, url]) => ({ name, url }))
    const datasources = mergeBy(predefinedDatasources, inputDatasources, source => source.name)

    const engineConfig = internal.engine || {}

    if (options.errorFormat) {
      this.errorFormat = options.errorFormat
    } else if (process.env.NODE_ENV === 'production') {
      this.errorFormat = 'minimal'
    } else if (process.env.NO_COLOR) {
      this.errorFormat = 'colorless'
    } else {
      this.errorFormat = 'pretty'
    }

    this.measurePerformance = internal.measurePerformance || false

    const envFile = this.readEnv()

    this.engineConfig = {
      cwd: engineConfig.cwd || path.resolve(__dirname, "../../../prisma"),
      debug: useDebug,
      datamodelPath: path.resolve(__dirname, 'schema.prisma'),
      prismaPath: engineConfig.binaryPath || undefined,
      datasources,
      generator: {"name":"client","provider":"prisma-client-js","output":"/Users/valentinoespinoza/readyup/node_modules/@prisma/client","binaryTargets":[],"config":{}},
      showColors: this.errorFormat === 'pretty',
      logLevel: options.log && getLogLevel(options.log),
      logQueries: options.log && Boolean(options.log.find(o => typeof o === 'string' ? o === 'query' : o.level === 'query')),
      env: envFile
    }

    debug({ engineConfig: this.engineConfig })

    this.engine = new Engine(this.engineConfig)

    this.dmmf = new DMMFClass(dmmf)

    this.fetcher = new PrismaClientFetcher(this, false, internal.hooks)

    if (options.log) {
      for (const log of options.log) {
        const level = typeof log === 'string' ? log : log.emit === 'stdout' ? log.level : null
        if (level) {
          this.on(level, event => {
            const colorMap = {
              query: 'blue',
              info: 'cyan',
              warn: 'yellow'
            }
            console.error(chalk[colorMap[level]](`prisma:${level}`.padEnd(13)) + (event.message || event.query))
          })
        }
      }
    }
  }

  /**
   * @private
   */
  readEnv() {
    const dotEnvPath = path.resolve(path.resolve(__dirname, "../../../prisma"), '.env')

    if (fs.existsSync(dotEnvPath)) {
      return parseDotenv(fs.readFileSync(dotEnvPath, 'utf-8'))
    }

    return {}
  }

  on(eventType, callback) {
    this.engine.on(eventType, event => {
      const fields = event.fields
      if (eventType === 'query') {
        callback({
          timestamp: event.timestamp,
          query: fields.query,
          params: fields.params,
          duration: fields.duration_ms,
          target: event.target
        })
      } else { // warn or info events
        callback({
          timestamp: event.timestamp,
          message: fields.message,
          target: event.target
        })
      }
    })
  }
  /**
   * Connect with the database
   */
  async connect() {
    if (this.disconnectionPromise) {
      debug('awaiting disconnection promise')
      await this.disconnectionPromise
    } else {
      debug('disconnection promise doesnt exist')
    }
    if (this.connectionPromise) {
      return this.connectionPromise
    }
    this.connectionPromise = this.engine.start()
    return this.connectionPromise
  }
  /**
   * @private
   */
  async runDisconnect() {
    debug('disconnectionPromise: stopping engine')
    await this.engine.stop()
    delete this.connectionPromise
    this.engine = new Engine(this.engineConfig)
    delete this.disconnectionPromise
  }
  /**
   * Disconnect from the database
   */
  async disconnect() {
    if (!this.disconnectionPromise) {
      this.disconnectionPromise = this.runDisconnect() 
    }
    return this.disconnectionPromise
  }
  /**
   * Makes a raw query
   */ 
  async raw(stringOrTemplateStringsArray) {
    let query = ''
    
    if (Array.isArray(stringOrTemplateStringsArray)) {
      if (stringOrTemplateStringsArray.length !== 1) {
        throw new Error('The prisma.raw method must be used like this prisma.raw`SELECT * FROM Posts` without template literal variables.')
      }
      // Called with prisma.raw``
      query = stringOrTemplateStringsArray[0]
    } else {
      query = stringOrTemplateStringsArray 
    }

    const document = makeDocument({
      dmmf: this.dmmf,
      rootField: "executeRaw",
      rootTypeName: 'mutation',
      select: {
        query
      }
    })

    document.validate({ query }, false, 'raw', this.errorFormat)
    
    return this.fetcher.request({ document, rootField: 'executeRaw', typeName: 'raw', isList: false})
  }

  /**
   * `prisma.reminder`: Exposes CRUD operations for the **Reminder** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Reminders
   * const reminders = await prisma.reminder.findMany()
   * ```
   */
  get reminder() {
    return ReminderDelegate(this.dmmf, this.fetcher, this.errorFormat, this.measurePerformance)
  }
}
exports.PrismaClient = PrismaClient



/**
 * Enums
 */
// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275
function makeEnum(x) { return x; }

exports.OrderByArg = makeEnum({
  asc: 'asc',
  desc: 'desc'
});


function ReminderDelegate(dmmf, fetcher, errorFormat, measurePerformance) {
  const Reminder = {} 
  Reminder.findOne = (args) => args && args.select ? new ReminderClient(
    dmmf,
    fetcher,
    'query',
    'findOneReminder',
    'reminders.findOne',
    args || {},
    [],
    errorFormat,
    measurePerformance
  ) : new ReminderClient(
    dmmf,
    fetcher,
    'query',
    'findOneReminder',
    'reminders.findOne',
    args || {},
    [],
    errorFormat,
    measurePerformance
  )
  Reminder.findMany = (args) => new ReminderClient(
    dmmf,
    fetcher,
    'query',
    'findManyReminder',
    'reminders.findMany',
    args || {},
    [],
    errorFormat,
    measurePerformance
  )
  Reminder.create = (args) => args && args.select ? new ReminderClient(
    dmmf,
    fetcher,
    'mutation',
    'createOneReminder',
    'reminders.create',
    args || {},
    [],
    errorFormat,
    measurePerformance
  ) : new ReminderClient(
    dmmf,
    fetcher,
    'mutation',
    'createOneReminder',
    'reminders.create',
    args || {},
    [],
    errorFormat,
    measurePerformance
  )
  Reminder.delete = (args) => args && args.select ? new ReminderClient(
    dmmf,
    fetcher,
    'mutation',
    'deleteOneReminder',
    'reminders.delete',
    args || {},
    [],
    errorFormat,
    measurePerformance
  ) : new ReminderClient(
    dmmf,
    fetcher,
    'mutation',
    'deleteOneReminder',
    'reminders.delete',
    args || {},
    [],
    errorFormat,
    measurePerformance
  )
  Reminder.update = (args) => args && args.select ? new ReminderClient(
    dmmf,
    fetcher,
    'mutation',
    'updateOneReminder',
    'reminders.update',
    args || {},
    [],
    errorFormat,
    measurePerformance
  ) : new ReminderClient(
    dmmf,
    fetcher,
    'mutation',
    'updateOneReminder',
    'reminders.update',
    args || {},
    [],
    errorFormat,
    measurePerformance
  )
  Reminder.deleteMany = (args) => new ReminderClient(
    dmmf,
    fetcher,
    'mutation',
    'deleteManyReminder',
    'reminders.deleteMany',
    args || {},
    [],
    errorFormat,
    measurePerformance
  )
  Reminder.updateMany = (args) => new ReminderClient(
    dmmf,
    fetcher,
    'mutation',
    'updateManyReminder',
    'reminders.updateMany',
    args || {},
    [],
    errorFormat,
    measurePerformance
  )
  Reminder.upsert = (args) => args && args.select ? new ReminderClient(
    dmmf,
    fetcher,
    'mutation',
    'upsertOneReminder',
    'reminders.upsert',
    args || {},
    [],
    errorFormat,
    measurePerformance
  ) : new ReminderClient(
    dmmf,
    fetcher,
    'mutation',
    'upsertOneReminder',
    'reminders.upsert',
    args || {},
    [],
    errorFormat,
    measurePerformance
  )
  Reminder.count = () => new ReminderClient(dmmf, fetcher, 'query', 'aggregateReminder', 'reminders.count', {}, ['count'], errorFormat)
  return Reminder
}

class ReminderClient {
  constructor(_dmmf, _fetcher, _queryType, _rootField, _clientMethod, _args, _dataPath, _errorFormat, _measurePerformance, _isList) {
    this._dmmf = _dmmf;
    this._fetcher = _fetcher;
    this._queryType = _queryType;
    this._rootField = _rootField;
    this._clientMethod = _clientMethod;
    this._args = _args;
    this._dataPath = _dataPath;
    this._errorFormat = _errorFormat;
    this._measurePerformance = _measurePerformance;
    this._isList = _isList;
    if (this._measurePerformance) {
      // Timestamps for performance checks
      this._collectTimestamps = new CollectTimestamps("PrismaClient");
    }
    // @ts-ignore
    if (process.env.NODE_ENV !== 'production' && this._errorFormat !== 'minimal') {
      const error = new Error();
      if (error && error.stack) {
        const stack = error.stack;
        this._callsite = stack;
      }
    }
  }


  get _document() {
    const { _rootField: rootField } = this
    this._collectTimestamps && this._collectTimestamps.record("Pre-makeDocument")
    const document = makeDocument({
      dmmf: this._dmmf,
      rootField,
      rootTypeName: this._queryType,
      select: this._args
    })
    this._collectTimestamps && this._collectTimestamps.record("Post-makeDocument")
    try {
      this._collectTimestamps && this._collectTimestamps.record("Pre-document.validate")
      document.validate(this._args, false, this._clientMethod, this._errorFormat)
      this._collectTimestamps && this._collectTimestamps.record("Post-document.validate")
    } catch (e) {
      const x = e
      if (this._errorFormat !== 'minimal' && x.render) {
        if (this._callsite) {
          e.message = x.render(this._callsite)
        }
      }
      throw e
    }
    this._collectTimestamps && this._collectTimestamps.record("Pre-transformDocument")
    const transformedDocument = transformDocument(document)
    this._collectTimestamps && this._collectTimestamps.record("Post-transformDocument")
    return transformedDocument
  }

  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then(onfulfilled, onrejected) {
    if (!this._requestPromise){
      this._requestPromise = this._fetcher.request({
        document: this._document,
        dataPath: this._dataPath,
        rootField: this._rootField,
        typeName: 'Reminder',
        isList: this._isList,
        callsite: this._callsite,
        collectTimestamps: this._collectTimestamps,
        clientMethod: this._clientMethod
      })
    }
    return this._requestPromise.then(onfulfilled, onrejected)
  }

  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch(onrejected) {
    if (!this._requestPromise) {
      this._requestPromise = this._fetcher.request({
        document: this._document,
        dataPath: this._dataPath,
        rootField: this._rootField,
        typeName: 'Reminder',
        isList: this._isList,
        callsite: this._callsite,
        collectTimestamps: this._collectTimestamps,
        clientMethod: this._clientMethod
      })
    }
    return this._requestPromise.catch(onrejected)
  }

  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally) {
    if (!this._requestPromise) {
      this._requestPromise = this._fetcher.request({
        document: this._document,
        dataPath: this._dataPath,
        rootField: this._rootField,
        typeName: 'Reminder',
        isList: this._isList,
        callsite: this._callsite,
        collectTimestamps: this._collectTimestamps,
        clientMethod: this._clientMethod
      })
    }
    return this._requestPromise.finally(onfinally)
  }
}

exports.ReminderClient = ReminderClient


/**
 * DMMF
 */
const dmmfString = '{"datamodel":{"enums":[],"models":[{"name":"Reminder","isEmbedded":false,"dbName":null,"fields":[{"name":"reminder_id","kind":"scalar","dbNames":[],"isList":false,"isRequired":true,"isUnique":false,"isId":true,"type":"Int","default":{"name":"autoincrement","returnType":"Int","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","dbNames":[],"isList":false,"isRequired":false,"isUnique":false,"isId":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"createdAt","kind":"scalar","dbNames":[],"isList":false,"isRequired":true,"isUnique":false,"isId":false,"type":"DateTime","default":{"name":"now","returnType":"DateTime","args":[]},"isGenerated":false,"isUpdatedAt":false}],"isGenerated":false,"idFields":[]}]},"mappings":[{"model":"Reminder","plural":"reminders","findOne":"findOneReminder","findMany":"findManyReminder","create":"createOneReminder","delete":"deleteOneReminder","update":"updateOneReminder","deleteMany":"deleteManyReminder","updateMany":"updateManyReminder","upsert":"upsertOneReminder","aggregate":"aggregateReminder"}],"schema":{"enums":[{"name":"OrderByArg","values":["asc","desc"]}],"outputTypes":[{"name":"Reminder","fields":[{"name":"reminder_id","args":[],"outputType":{"type":"Int","kind":"scalar","isRequired":true,"isList":false}},{"name":"name","args":[],"outputType":{"type":"String","kind":"scalar","isRequired":false,"isList":false}},{"name":"createdAt","args":[],"outputType":{"type":"DateTime","kind":"scalar","isRequired":true,"isList":false}}]},{"name":"AggregateReminder","fields":[{"name":"count","args":[],"outputType":{"type":"Int","kind":"scalar","isRequired":true,"isList":false}}]},{"name":"Query","fields":[{"name":"findManyReminder","args":[{"name":"where","inputType":[{"type":"ReminderWhereInput","kind":"object","isRequired":false,"isList":false}]},{"name":"orderBy","inputType":[{"isList":false,"isRequired":false,"type":"ReminderOrderByInput","kind":"object"}]},{"name":"skip","inputType":[{"type":"Int","kind":"scalar","isRequired":false,"isList":false}]},{"name":"after","inputType":[{"type":"ReminderWhereUniqueInput","kind":"object","isRequired":false,"isList":false}]},{"name":"before","inputType":[{"type":"ReminderWhereUniqueInput","kind":"object","isRequired":false,"isList":false}]},{"name":"first","inputType":[{"type":"Int","kind":"scalar","isRequired":false,"isList":false}]},{"name":"last","inputType":[{"type":"Int","kind":"scalar","isRequired":false,"isList":false}]}],"outputType":{"type":"Reminder","kind":"object","isRequired":true,"isList":true}},{"name":"aggregateReminder","args":[],"outputType":{"type":"AggregateReminder","kind":"object","isRequired":true,"isList":false}},{"name":"findOneReminder","args":[{"name":"where","inputType":[{"type":"ReminderWhereUniqueInput","kind":"object","isRequired":true,"isList":false}]}],"outputType":{"type":"Reminder","kind":"object","isRequired":false,"isList":false}}]},{"name":"BatchPayload","fields":[{"name":"count","args":[],"outputType":{"type":"Int","kind":"scalar","isRequired":true,"isList":false}}]},{"name":"Mutation","fields":[{"name":"createOneReminder","args":[{"name":"data","inputType":[{"type":"ReminderCreateInput","kind":"object","isRequired":true,"isList":false}]}],"outputType":{"type":"Reminder","kind":"object","isRequired":true,"isList":false}},{"name":"deleteOneReminder","args":[{"name":"where","inputType":[{"type":"ReminderWhereUniqueInput","kind":"object","isRequired":true,"isList":false}]}],"outputType":{"type":"Reminder","kind":"object","isRequired":false,"isList":false}},{"name":"updateOneReminder","args":[{"name":"data","inputType":[{"type":"ReminderUpdateInput","kind":"object","isRequired":true,"isList":false}]},{"name":"where","inputType":[{"type":"ReminderWhereUniqueInput","kind":"object","isRequired":true,"isList":false}]}],"outputType":{"type":"Reminder","kind":"object","isRequired":false,"isList":false}},{"name":"upsertOneReminder","args":[{"name":"where","inputType":[{"type":"ReminderWhereUniqueInput","kind":"object","isRequired":true,"isList":false}]},{"name":"create","inputType":[{"type":"ReminderCreateInput","kind":"object","isRequired":true,"isList":false}]},{"name":"update","inputType":[{"type":"ReminderUpdateInput","kind":"object","isRequired":true,"isList":false}]}],"outputType":{"type":"Reminder","kind":"object","isRequired":true,"isList":false}},{"name":"updateManyReminder","args":[{"name":"data","inputType":[{"type":"ReminderUpdateManyMutationInput","kind":"object","isRequired":true,"isList":false}]},{"name":"where","inputType":[{"type":"ReminderWhereInput","kind":"object","isRequired":false,"isList":false}]}],"outputType":{"type":"BatchPayload","kind":"object","isRequired":true,"isList":false}},{"name":"deleteManyReminder","args":[{"name":"where","inputType":[{"type":"ReminderWhereInput","kind":"object","isRequired":false,"isList":false}]}],"outputType":{"type":"BatchPayload","kind":"object","isRequired":true,"isList":false}},{"name":"executeRaw","args":[{"name":"query","inputType":[{"type":"String","kind":"scalar","isRequired":true,"isList":false}]},{"name":"parameters","inputType":[{"type":"Json","kind":"scalar","isRequired":false,"isList":false}]}],"outputType":{"type":"Json","kind":"scalar","isRequired":true,"isList":false}}]}],"inputTypes":[{"name":"ReminderWhereInput","fields":[{"name":"reminder_id","inputType":[{"isList":false,"isRequired":false,"kind":"scalar","type":"Int"},{"type":"IntFilter","isList":false,"isRequired":false,"kind":"object"}],"isRelationFilter":false},{"name":"name","inputType":[{"isList":false,"isRequired":false,"kind":"scalar","type":"String"},{"type":"NullableStringFilter","isList":false,"isRequired":false,"kind":"object"},{"type":"null","isList":false,"isRequired":false,"kind":"scalar"}],"isRelationFilter":false},{"name":"createdAt","inputType":[{"isList":false,"isRequired":false,"kind":"scalar","type":"DateTime"},{"type":"DateTimeFilter","isList":false,"isRequired":false,"kind":"object"}],"isRelationFilter":false},{"name":"AND","inputType":[{"type":"ReminderWhereInput","kind":"object","isRequired":false,"isList":true}],"isRelationFilter":true},{"name":"OR","inputType":[{"type":"ReminderWhereInput","kind":"object","isRequired":false,"isList":true}],"isRelationFilter":true},{"name":"NOT","inputType":[{"type":"ReminderWhereInput","kind":"object","isRequired":false,"isList":true}],"isRelationFilter":true}],"isWhereType":true,"atLeastOne":false},{"name":"ReminderWhereUniqueInput","fields":[{"name":"reminder_id","inputType":[{"type":"Int","kind":"scalar","isRequired":false,"isList":false}]}],"atLeastOne":true},{"name":"ReminderCreateInput","fields":[{"name":"name","inputType":[{"type":"String","kind":"scalar","isRequired":false,"isList":false}]},{"name":"createdAt","inputType":[{"type":"DateTime","kind":"scalar","isRequired":false,"isList":false}]}]},{"name":"ReminderUpdateInput","fields":[{"name":"reminder_id","inputType":[{"type":"Int","kind":"scalar","isRequired":false,"isList":false}]},{"name":"name","inputType":[{"type":"String","kind":"scalar","isRequired":false,"isList":false}]},{"name":"createdAt","inputType":[{"type":"DateTime","kind":"scalar","isRequired":false,"isList":false}]}]},{"name":"ReminderUpdateManyMutationInput","fields":[{"name":"reminder_id","inputType":[{"type":"Int","kind":"scalar","isRequired":false,"isList":false}]},{"name":"name","inputType":[{"type":"String","kind":"scalar","isRequired":false,"isList":false}]},{"name":"createdAt","inputType":[{"type":"DateTime","kind":"scalar","isRequired":false,"isList":false}]}]},{"name":"IntFilter","fields":[{"name":"equals","isRelationFilter":false,"inputType":[{"isList":false,"isRequired":false,"kind":"scalar","type":"Int"}]},{"name":"not","isRelationFilter":false,"inputType":[{"isList":false,"isRequired":false,"kind":"scalar","type":"Int"},{"isList":false,"isRequired":false,"kind":"scalar","type":"IntFilter"}]},{"name":"in","isRelationFilter":false,"inputType":[{"isList":true,"isRequired":false,"kind":"scalar","type":"Int"}]},{"name":"notIn","isRelationFilter":false,"inputType":[{"isList":true,"isRequired":false,"kind":"scalar","type":"Int"}]},{"name":"lt","isRelationFilter":false,"inputType":[{"isList":false,"isRequired":false,"kind":"scalar","type":"Int"}]},{"name":"lte","isRelationFilter":false,"inputType":[{"isList":false,"isRequired":false,"kind":"scalar","type":"Int"}]},{"name":"gt","isRelationFilter":false,"inputType":[{"isList":false,"isRequired":false,"kind":"scalar","type":"Int"}]},{"name":"gte","isRelationFilter":false,"inputType":[{"isList":false,"isRequired":false,"kind":"scalar","type":"Int"}]}],"atLeastOne":false},{"name":"NullableStringFilter","fields":[{"name":"equals","isRelationFilter":false,"inputType":[{"isList":false,"isRequired":false,"kind":"scalar","type":"String"},{"isList":false,"isRequired":false,"kind":"scalar","type":"null"}]},{"name":"not","isRelationFilter":false,"inputType":[{"isList":false,"isRequired":false,"kind":"scalar","type":"String"},{"isList":false,"isRequired":false,"kind":"scalar","type":"null"},{"isList":false,"isRequired":false,"kind":"scalar","type":"NullableStringFilter"}]},{"name":"in","isRelationFilter":false,"inputType":[{"isList":true,"isRequired":false,"kind":"scalar","type":"String"}]},{"name":"notIn","isRelationFilter":false,"inputType":[{"isList":true,"isRequired":false,"kind":"scalar","type":"String"}]},{"name":"lt","isRelationFilter":false,"inputType":[{"isList":false,"isRequired":false,"kind":"scalar","type":"String"}]},{"name":"lte","isRelationFilter":false,"inputType":[{"isList":false,"isRequired":false,"kind":"scalar","type":"String"}]},{"name":"gt","isRelationFilter":false,"inputType":[{"isList":false,"isRequired":false,"kind":"scalar","type":"String"}]},{"name":"gte","isRelationFilter":false,"inputType":[{"isList":false,"isRequired":false,"kind":"scalar","type":"String"}]},{"name":"contains","isRelationFilter":false,"inputType":[{"isList":false,"isRequired":false,"kind":"scalar","type":"String"}]},{"name":"startsWith","isRelationFilter":false,"inputType":[{"isList":false,"isRequired":false,"kind":"scalar","type":"String"}]},{"name":"endsWith","isRelationFilter":false,"inputType":[{"isList":false,"isRequired":false,"kind":"scalar","type":"String"}]}],"atLeastOne":false},{"name":"DateTimeFilter","fields":[{"name":"equals","isRelationFilter":false,"inputType":[{"isList":false,"isRequired":false,"kind":"scalar","type":"DateTime"}]},{"name":"not","isRelationFilter":false,"inputType":[{"isList":false,"isRequired":false,"kind":"scalar","type":"DateTime"},{"isList":false,"isRequired":false,"kind":"scalar","type":"DateTimeFilter"}]},{"name":"in","isRelationFilter":false,"inputType":[{"isList":true,"isRequired":false,"kind":"scalar","type":"DateTime"}]},{"name":"notIn","isRelationFilter":false,"inputType":[{"isList":true,"isRequired":false,"kind":"scalar","type":"DateTime"}]},{"name":"lt","isRelationFilter":false,"inputType":[{"isList":false,"isRequired":false,"kind":"scalar","type":"DateTime"}]},{"name":"lte","isRelationFilter":false,"inputType":[{"isList":false,"isRequired":false,"kind":"scalar","type":"DateTime"}]},{"name":"gt","isRelationFilter":false,"inputType":[{"isList":false,"isRequired":false,"kind":"scalar","type":"DateTime"}]},{"name":"gte","isRelationFilter":false,"inputType":[{"isList":false,"isRequired":false,"kind":"scalar","type":"DateTime"}]}],"atLeastOne":false},{"name":"ReminderOrderByInput","atLeastOne":true,"atMostOne":true,"isOrderType":true,"fields":[{"name":"reminder_id","inputType":[{"type":"OrderByArg","isList":false,"isRequired":false,"kind":"enum"}],"isRelationFilter":false},{"name":"name","inputType":[{"type":"OrderByArg","isList":false,"isRequired":false,"kind":"enum"}],"isRelationFilter":false},{"name":"createdAt","inputType":[{"type":"OrderByArg","isList":false,"isRequired":false,"kind":"enum"}],"isRelationFilter":false}]}]}}'

// We are parsing 2 times, as we want independent objects, because
// DMMFClass introduces circular references in the dmmf object
const dmmf = JSON.parse(dmmfString)
exports.dmmf = JSON.parse(dmmfString)
    
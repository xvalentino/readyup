"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
require("flat-map-polyfill"); // unfortunately needed as it's not properly polyfilled in TypeScript
const indent_string_1 = __importDefault(require("indent-string"));
const dmmf_1 = require("../runtime/dmmf");
const dmmf_types_1 = require("../runtime/dmmf-types");
const pluralize_1 = __importDefault(require("pluralize"));
const common_1 = require("../runtime/utils/common");
const serializeDatasources_1 = require("./serializeDatasources");
const utils_1 = require("./utils");
const uniqueBy_1 = require("../runtime/utils/uniqueBy");
const tab = 2;
function JS(gen) {
    if (gen.toJS) {
        return gen.toJS();
    }
    return '';
}
exports.JS = JS;
function TS(gen) {
    return gen.toTS();
}
exports.TS = TS;
const commonCodeJS = (runtimePath, version) => `
Object.defineProperty(exports, "__esModule", { value: true });

const {
  DMMF,
  DMMFClass,
  deepGet,
  deepSet,
  makeDocument,
  Engine,
  debugLib,
  transformDocument,
  chalk,
  printStack,
  mergeBy,
  unpack,
  stripAnsi,
  parseDotenv,
  Dataloader,
  PrismaClientKnownRequestError,
  PrismaClientUnknownRequestError,
  PrismaClientRustPanicError,
  PrismaClientInitializationError,
  PrismaClientValidationError,
  lowerCase
} = require('${runtimePath}')

/**
 * Query Engine version: ${version || 'latest'}
 */

const path = require('path')
const fs = require('fs')

const debug = debugLib('prisma-client')

exports.PrismaClientKnownRequestError = PrismaClientKnownRequestError;
exports.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError;
exports.PrismaClientRustPanicError = PrismaClientRustPanicError;
exports.PrismaClientInitializationError = PrismaClientInitializationError;
exports.PrismaClientValidationError = PrismaClientValidationError;

class PrismaClientFetcher {
  constructor(prisma, enableDebug = false, hooks) {
    this.prisma = prisma;
    this.debug = enableDebug;
    this.hooks = hooks;
    this.dataloader = new Dataloader(async (requests) => {
      // TODO: More elaborate logic to only batch certain queries together
      // We should e.g. make sure, that findOne queries are batched together
      await this.prisma.connect();
      const queries = requests.map(r => String(r.document))
      debug('Requests:')
      debug(queries)
      const results = await this.prisma.engine.request(queries)
      debug('Results:')
      debug(results)
      return results
    })
  }
  async request({ document, dataPath = [], rootField, typeName, isList, callsite, collectTimestamps, clientMethod }) {
    if (this.hooks && this.hooks.beforeRequest) {
      const query = String(document);
      this.hooks.beforeRequest({ query, path: dataPath, rootField, typeName, document });
    }
    try {
      collectTimestamps && collectTimestamps.record("Pre-prismaClientConnect");
      collectTimestamps && collectTimestamps.record("Post-prismaClientConnect");
      collectTimestamps && collectTimestamps.record("Pre-engine_request");
      const result = await this.dataloader.request({ document });
      collectTimestamps && collectTimestamps.record("Post-engine_request");
      collectTimestamps && collectTimestamps.record("Pre-unpack");
      const unpackResult = this.unpack(document, result, dataPath, rootField, isList);
      collectTimestamps && collectTimestamps.record("Post-unpack");
      return unpackResult;
    } catch (e) {
      debug(e.stack);
      if (callsite) {
        const { stack } = printStack({
          callsite,
          originalMethod: clientMethod,
          onUs: e.isPanic
        });
        const message = stack + e.message;
        if (e.code) {
          throw new PrismaClientKnownRequestError(this.sanitizeMessage(message), e.code, e.meta);
        }
        if (e instanceof PrismaClientUnknownRequestError) {
          throw new PrismaClientUnknownRequestError(this.sanitizeMessage(message));
        } else if (e instanceof PrismaClientInitializationError) {
          throw new PrismaClientInitializationError(this.sanitizeMessage(message));
        } else if (e instanceof PrismaClientRustPanicError) {
          throw new PrismaClientRustPanicError(this.sanitizeMessage(message));
        }
      } else {
        if (e.code) {
          throw new PrismaClientKnownRequestError(this.sanitizeMessage(e.message), e.code, e.meta);
        }
        if (e.isPanic) {
          throw new PrismaClientRustPanicError(e.message);
        } else {
          if (e instanceof PrismaClientUnknownRequestError) {
            throw new PrismaClientUnknownRequestError(this.sanitizeMessage(message));
          } else if (e instanceof PrismaClientInitializationError) {
            throw new PrismaClientInitializationError(this.sanitizeMessage(message));
          } else if (e instanceof PrismaClientRustPanicError) {
            throw new PrismaClientRustPanicError(this.sanitizeMessage(message));
          }
        }
      }
    }
  }
  sanitizeMessage(message) {
    if (this.prisma.errorFormat && this.prisma.errorFormat !== 'pretty') {
      return stripAnsi(message);
    }
    return message;
  }
  unpack(document, data, path, rootField, isList) {
    if (data.data) {
      data = data.data
    }
    const getPath = [];
    if (rootField) {
      getPath.push(rootField);
    }
    getPath.push(...path.filter(p => p !== 'select' && p !== 'include'));
    return unpack({ document, data, path: getPath });
  }
}

class CollectTimestamps {
  constructor(startName) {
    this.records = [];
    this.start = undefined;
    this.additionalResults = {};
    this.start = { name: startName, value: process.hrtime() };
  }
  record(name) {
    this.records.push({ name, value: process.hrtime() });
  }
  elapsed(start, end) {
    const diff = [end[0] - start[0], end[1] - start[1]];
    const nanoseconds = (diff[0] * 1e9) + diff[1];
    const milliseconds = nanoseconds / 1e6;
    return milliseconds;
  }
  addResults(results) {
    Object.assign(this.additionalResults, results);
  }
  getResults() {
    const results = this.records.reduce((acc, record) => {
      const name = record.name.split('-')[1];
      if (acc[name]) {
        acc[name] = this.elapsed(acc[name], record.value);
      }
      else {
        acc[name] = record.value;
      }
      return acc;
    }, {});
    Object.assign(results, {
      total: this.elapsed(this.start.value, this.records[this.records.length - 1].value),
      ...this.additionalResults
    });
    return results;
  }
}
`;
const commonCodeTS = (runtimePath, version) => `import {
  DMMF,
  DMMFClass,
  Engine,
  PrismaClientKnownRequestError,
  PrismaClientUnknownRequestError,
  PrismaClientRustPanicError,
  PrismaClientInitializationError,
  PrismaClientValidationError,
} from '${runtimePath}';

export { PrismaClientKnownRequestError }
export { PrismaClientUnknownRequestError }
export { PrismaClientRustPanicError }
export { PrismaClientInitializationError }
export { PrismaClientValidationError }

/**
 * Query Engine version: ${version || 'latest'}
 */

/**
 * Utility Types
 */

/**
 * Get the type of the value, that the Promise holds.
 */
export declare type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

/**
 * Get the return type of a function which returns a Promise.
 */
export declare type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>


export declare type Enumerable<T> = T | Array<T>;
export declare type MergeTruthyValues<R extends object, S extends object> = {
  [key in keyof S | keyof R]: key extends false ? never : key extends keyof S ? S[key] extends false ? never : S[key] : key extends keyof R ? R[key] : never;
};
export declare type CleanupNever<T> = {
  [key in keyof T]: T[key] extends never ? never : key;
}[keyof T];
/**
 * Subset
 * @desc From \`T\` pick properties that exist in \`U\`. Simple version of Intersection
 */
export declare type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};
declare class PrismaClientFetcher {
  private readonly prisma;
  private readonly debug;
  private readonly hooks?;
  constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
  request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string, collectTimestamps?: any): Promise<T>;
  sanitizeMessage(message: string): string;
  protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
}
`;
class TSClient {
    constructor({ document, runtimePath, browser = false, datasources, generator, platforms, sqliteDatasourceOverrides, schemaDir, outputDir, }) {
        this.document = document;
        this.runtimePath = runtimePath;
        this.browser = browser;
        this.internalDatasources = datasources;
        this.generator = generator;
        this.platforms = platforms;
        this.sqliteDatasourceOverrides = sqliteDatasourceOverrides;
        // We make a deep clone here as otherwise we would serialize circular references
        // which we're building up in the DMMFClass
        this.dmmf = new dmmf_1.DMMFClass(JSON.parse(JSON.stringify(document)));
        this.schemaDir = schemaDir;
        this.outputDir = outputDir;
    }
    toJS() {
        return `${commonCodeJS(this.runtimePath, this.version)}

/**
 * Build tool annotations
 * In order to make \`ncc\` and \`node-file-trace\` happy.
**/

${this.platforms
            ? this.platforms
                .map(p => `path.join(__dirname, 'runtime/query-engine-${p}');`)
                .join('\n')
            : ''}

/**
 * Client
**/

${new PrismaClientClass(this.dmmf, this.internalDatasources, this.outputDir, this.browser, this.generator, this.sqliteDatasourceOverrides, this.schemaDir).toJS()}


/**
 * Enums
 */
// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275
function makeEnum(x) { return x; }

${this.dmmf.schema.enums.map(type => new Enum(type).toJS()).join('\n\n')}


${Object.values(this.dmmf.modelMap)
            .map(model => new Model(model, this.dmmf).toJS())
            .join('\n')}

/**
 * DMMF
 */
const dmmfString = '${JSON.stringify(this.document)}'

// We are parsing 2 times, as we want independent objects, because
// DMMFClass introduces circular references in the dmmf object
const dmmf = JSON.parse(dmmfString)
exports.dmmf = JSON.parse(dmmfString)
    `;
    }
    toTS() {
        return `${commonCodeTS(this.runtimePath, this.version)}

/**
 * Client
**/

${new PrismaClientClass(this.dmmf, this.internalDatasources, this.outputDir, this.browser, this.generator, this.sqliteDatasourceOverrides, this.schemaDir).toTS()}

${ /*new Query(this.dmmf, 'query')*/''}

/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

${this.dmmf.schema.enums.map(type => new Enum(type).toTS()).join('\n\n')}

${Object.values(this.dmmf.modelMap)
            .map(model => new Model(model, this.dmmf).toTS())
            .join('\n')}

/**
 * Deep Input Types
 */

${this.dmmf.inputTypes
            .map(inputType => new InputType(inputType).toTS())
            .join('\n')}

/**
 * Batch Payload for updateMany & deleteMany
 */

export type BatchPayload = {
  count: number
}

/**
 * DMMF
 */
export declare const dmmf: DMMF.Document;
export {};
`;
    }
}
exports.TSClient = TSClient;
class Datasources {
    constructor(internalDatasources) {
        this.internalDatasources = internalDatasources;
    }
    toTS() {
        const sources = this.internalDatasources;
        return `export type Datasources = {
${indent_string_1.default(sources.map(s => `${s.name}?: string`).join('\n'), 2)}
}`;
    }
}
class PrismaClientClass {
    constructor(dmmf, internalDatasources, outputDir, browser, generator, sqliteDatasourceOverrides, cwd) {
        this.dmmf = dmmf;
        this.internalDatasources = internalDatasources;
        this.outputDir = outputDir;
        this.browser = browser;
        this.generator = generator;
        this.sqliteDatasourceOverrides = sqliteDatasourceOverrides;
        this.cwd = cwd;
    }
    toJS() {
        const { dmmf } = this;
        return `// tested in getLogLevel.test.ts
function getLogLevel(log) {
    return log.reduce((acc, curr) => {
        const currentLevel = typeof curr === 'string' ? curr : curr.level;
        if (currentLevel === 'query') {
            return acc;
        }
        if (!acc) {
            return currentLevel;
        }
        if (curr === 'info' || acc === 'info') {
            // info always has precedence
            return 'info';
        }
        return currentLevel;
    }, undefined);
}
exports.getLogLevel = getLogLevel;

${this.jsDoc}
class PrismaClient {
${this.jsDoc}
  constructor(optionsArg) {
    const options = optionsArg || {}
    const internal = options.__internal || {}

    const useDebug = internal.debug === true
    if (useDebug) {
      debugLib.enable('prisma-client')
    }

    // datamodel = datamodel without datasources + printed datasources

    const predefinedDatasources = ${this.sqliteDatasourceOverrides
            ? utils_1.indentAllButFirstLine(serializeDatasources_1.serializeDatasources(this.sqliteDatasourceOverrides), 4)
            : '[]'}
    const inputDatasources = Object.entries(options.datasources || {}).map(([name, url]) => ({ name, url }))
    const datasources = mergeBy(predefinedDatasources, inputDatasources, source => source.name)

    const engineConfig = internal.engine || {}

    if (options.errorFormat) {
      this.errorFormat = options.errorFormat
    } else if (process.env.NODE_ENV === 'production') {
      this.errorFormat = 'minimal'
    } else if (process.env.NO_COLOR) {
      this.errorFormat = 'colorless'
    } else {
      this.errorFormat = 'pretty'
    }

    this.measurePerformance = internal.measurePerformance || false

    const envFile = this.readEnv()

    this.engineConfig = {
      cwd: engineConfig.cwd || ${utils_1.getRelativePathResolveStatement(this.outputDir, this.cwd)},
      debug: useDebug,
      datamodelPath: path.resolve(__dirname, 'schema.prisma'),
      prismaPath: engineConfig.binaryPath || undefined,
      datasources,
      generator: ${this.generator ? JSON.stringify(this.generator) : 'undefined'},
      showColors: this.errorFormat === 'pretty',
      logLevel: options.log && getLogLevel(options.log),
      logQueries: options.log && Boolean(options.log.find(o => typeof o === 'string' ? o === 'query' : o.level === 'query')),
      env: envFile
    }

    debug({ engineConfig: this.engineConfig })

    this.engine = new Engine(this.engineConfig)

    this.dmmf = new DMMFClass(dmmf)

    this.fetcher = new PrismaClientFetcher(this, false, internal.hooks)

    if (options.log) {
      for (const log of options.log) {
        const level = typeof log === 'string' ? log : log.emit === 'stdout' ? log.level : null
        if (level) {
          this.on(level, event => {
            const colorMap = {
              query: 'blue',
              info: 'cyan',
              warn: 'yellow'
            }
            console.error(chalk[colorMap[level]](\`prisma:$\{level\}\`.padEnd(13)) + (event.message || event.query))
          })
        }
      }
    }
  }

  /**
   * @private
   */
  readEnv() {
    const dotEnvPath = path.resolve(${utils_1.getRelativePathResolveStatement(this.outputDir, this.cwd)}, '.env')

    if (fs.existsSync(dotEnvPath)) {
      return parseDotenv(fs.readFileSync(dotEnvPath, 'utf-8'))
    }

    return {}
  }

  on(eventType, callback) {
    this.engine.on(eventType, event => {
      const fields = event.fields
      if (eventType === 'query') {
        callback({
          timestamp: event.timestamp,
          query: fields.query,
          params: fields.params,
          duration: fields.duration_ms,
          target: event.target
        })
      } else { // warn or info events
        callback({
          timestamp: event.timestamp,
          message: fields.message,
          target: event.target
        })
      }
    })
  }
  /**
   * Connect with the database
   */
  async connect() {
    if (this.disconnectionPromise) {
      debug('awaiting disconnection promise')
      await this.disconnectionPromise
    } else {
      debug('disconnection promise doesnt exist')
    }
    if (this.connectionPromise) {
      return this.connectionPromise
    }
    this.connectionPromise = this.engine.start()
    return this.connectionPromise
  }
  /**
   * @private
   */
  async runDisconnect() {
    debug('disconnectionPromise: stopping engine')
    await this.engine.stop()
    delete this.connectionPromise
    this.engine = new Engine(this.engineConfig)
    delete this.disconnectionPromise
  }
  /**
   * Disconnect from the database
   */
  async disconnect() {
    if (!this.disconnectionPromise) {
      this.disconnectionPromise = this.runDisconnect() 
    }
    return this.disconnectionPromise
  }
  /**
   * Makes a raw query
   */ 
  async raw(stringOrTemplateStringsArray) {
    let query = ''
    
    if (Array.isArray(stringOrTemplateStringsArray)) {
      if (stringOrTemplateStringsArray.length !== 1) {
        throw new Error('The prisma.raw method must be used like this prisma.raw\`SELECT * FROM Posts\` without template literal variables.')
      }
      // Called with prisma.raw\`\`
      query = stringOrTemplateStringsArray[0]
    } else {
      query = stringOrTemplateStringsArray 
    }

    const document = makeDocument({
      dmmf: this.dmmf,
      rootField: "executeRaw",
      rootTypeName: 'mutation',
      select: {
        query
      }
    })

    document.validate({ query }, false, 'raw', this.errorFormat)
    
    return this.fetcher.request({ document, rootField: 'executeRaw', typeName: 'raw', isList: false})
  }

${indent_string_1.default(dmmf.mappings
            .filter(m => m.findMany)
            .map(m => {
            const methodName = common_1.lowerCase(m.model);
            return `\
/**
 * \`prisma.${methodName}\`: Exposes CRUD operations for the **${m.model}** model.
 * Example usage:
 * \`\`\`ts
 * // Fetch zero or more ${common_1.capitalize(m.plural)}
 * const ${common_1.lowerCase(m.plural)} = await prisma.${methodName}.findMany()
 * \`\`\`
 */
get ${methodName}() {
  return ${m.model}Delegate(this.dmmf, this.fetcher, this.errorFormat, this.measurePerformance)
}`;
        })
            .join('\n'), 2)}
}
exports.PrismaClient = PrismaClient
`;
    }
    get jsDoc() {
        const { dmmf } = this;
        const example = dmmf.mappings[0];
        return `/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * \`\`\`
 * const prisma = new PrismaClient()
 * // Fetch zero or more ${common_1.capitalize(example.plural)}
 * const ${common_1.lowerCase(example.plural)} = await prisma.${common_1.lowerCase(example.model)}.findMany()
 * \`\`\`
 *
 * 
 * Read more in our [docs](https://github.com/prisma/prisma2/blob/master/docs/prisma-client-js/api.md).
 */`;
    }
    toTS() {
        const { dmmf } = this;
        return `
${new Datasources(this.internalDatasources).toTS()}

export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

export interface PrismaClientOptions {
  datasources?: Datasources

  /**
   * @default "pretty"
   */
  errorFormat?: ErrorFormat

  log?: Array<LogLevel | LogDefinition>

  /**
   * You probably don't want to use this. \`__internal\` is used by internal tooling.
   */
  __internal?: {
    debug?: boolean
    hooks?: Hooks
    engine?: {
      cwd?: string
      binaryPath?: string
    }
    measurePerformance?: boolean
  }
}

export type Hooks = {
  beforeRequest?: (options: {query: string, path: string[], rootField?: string, typeName?: string, document: any}) => any
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
export type GetEvents<T extends Array<LogLevel | LogDefinition>> = GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]>

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */

// tested in getLogLevel.test.ts
export declare function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

${this.jsDoc}
export declare class PrismaClient<T extends PrismaClientOptions = {}, U = keyof T extends 'log' ? T['log'] extends Array<LogLevel | LogDefinition> ? GetEvents<T['log']> : never : never> {
  /**
   * @private
   */
  private fetcher;
  /**
   * @private
   */
  private readonly dmmf;
  /**
   * @private
   */
  private connectionPromise?;
  /**
   * @private
   */
  private disconnectionPromise?;
  /**
   * @private
   */
  private readonly engineConfig;
  /**
   * @private
   */
  private readonly measurePerformance;
  /**
   * @private
   */
  private engine: Engine;
  /**
   * @private
   */
  private errorFormat: ErrorFormat;

${indent_string_1.default(this.jsDoc, tab)}
  constructor(optionsArg?: T);
  on<V extends U>(eventType: V, callback: V extends never ? never : (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * Connect with the database
   */
  connect(): Promise<void>;
  /**
   * @private
   */
  private runDisconnect;
  /**
   * Disconnect from the database
   */
  disconnect(): Promise<any>;
  /**
   * Makes a raw query
   * @example
   * \`\`\`
   * // Fetch all entries from the \`User\` table
   * const result = await prisma.raw\`SELECT * FROM User;\`
   * // Or
   * const result = await prisma.raw('SELECT * FROM User;')
  * \`\`\`
  * 
  * Read more in our [docs](https://github.com/prisma/prisma2/blob/master/docs/prisma-client-js/api.md#raw-database-access).
  */
  raw<T = any>(query: string | TemplateStringsArray): Promise<T>;

${indent_string_1.default(dmmf.mappings
            .filter(m => m.findMany)
            .map(m => {
            const methodName = common_1.lowerCase(m.model);
            return `\
/**
 * \`prisma.${methodName}\`: Exposes CRUD operations for the **${m.model}** model.
  * Example usage:
  * \`\`\`ts
  * // Fetch zero or more ${common_1.capitalize(m.plural)}
  * const ${common_1.lowerCase(m.plural)} = await prisma.${methodName}.findMany()
  * \`\`\`
  */
get ${methodName}(): ${m.model}Delegate;`;
        })
            .join('\n\n'), 2)}
}`;
    }
}
class QueryPayloadType {
    constructor(type) {
        this.type = type;
    }
    toTS() {
        const { type } = this;
        const { name } = type;
        const relationFields = type.fields.filter(f => f.outputType.kind === 'object' && f.name !== 'node');
        const relationFieldConditions = relationFields.length === 0
            ? ''
            : `\n${relationFields
                .map(f => indent_string_1.default(`: P extends '${f.name}'\n? ${this.wrapArray(f, `${utils_1.getPayloadName(f.outputType.type.name, utils_1.Projection.select)}<Extract${utils_1.getModelArgName(f.outputType.type.name, utils_1.Projection.select, f.outputType.isList
                ? dmmf_types_1.DMMF.ModelAction.findMany
                : dmmf_types_1.DMMF.ModelAction.findOne)}<S[P]>>`)}`, 8))
                .join('\n')}`;
        return `\
type ${utils_1.getPayloadName(name, utils_1.Projection.select)}<S extends ${name}Args> = S extends ${name}Args
  ? {
      [P in keyof S] ${relationFieldConditions}
        : never
    } : never
  `;
    }
    wrapArray(field, str) {
        if (field.outputType.isList) {
            return `Array<${str}>`;
        }
        return str;
    }
}
/**
 * Generates the generic type to calculate a payload based on a include statement
 */
class PayloadType {
    constructor(type, projection) {
        this.type = type;
        this.projection = projection;
    }
    toTS() {
        const { type, projection } = this;
        const { name } = type;
        const relationFields = type.fields.filter(f => f.outputType.kind === 'object');
        const relationFieldConditions = relationFields.length === 0
            ? ''
            : `\n${relationFields
                .map(f => indent_string_1.default(`: P extends '${f.name}'\n? ${this.wrapArray(f, `${utils_1.getPayloadName(f.outputType.type.name, projection)}<Extract${utils_1.getFieldArgName(f, projection)}<S[P]>>${!f.outputType.isRequired && !f.outputType.isList
                ? ' | null'
                : ''}`)}`, 8))
                .join('\n')}`;
        const hasScalarFields = type.fields.filter(f => f.outputType.kind !== 'object').length > 0;
        const projectionName = projection === utils_1.Projection.select
            ? utils_1.getSelectName(name)
            : utils_1.getIncludeName(name);
        return `\
export type ${utils_1.getPayloadName(name, projection)}<S extends boolean | ${projectionName}> = S extends true
  ? ${name}
  : S extends ${projectionName}
  ? {
      [P in CleanupNever<MergeTruthyValues<${projection === utils_1.Projection.select ? '{}' : utils_1.getDefaultName(name)}, S>>]${hasScalarFields
            ? `: P extends ${utils_1.getScalarsName(name)}
        ? ${name}[P]`
            : ''}${relationFieldConditions}
        : never
    }
   : never`;
    }
    wrapArray(field, str) {
        if (field.outputType.isList) {
            return `Array<${str}>`;
        }
        return str;
    }
}
/**
 * Generates the default selection of a model
 */
class ModelDefault {
    constructor(model, dmmf) {
        this.model = model;
        this.dmmf = dmmf;
    }
    toTS() {
        const { model } = this;
        return `\
type ${utils_1.getDefaultName(model.name)} = {
${indent_string_1.default(model.fields
            .filter(f => this.isDefault(f))
            .map(f => `${f.name}: true`)
            .join('\n'), tab)}
}
`;
    }
    isDefault(field) {
        if (field.kind !== 'object') {
            return true;
        }
        const model = this.dmmf.datamodel.models.find(m => field.type === m.name);
        return model.isEmbedded;
    }
}
class Model {
    constructor(model, dmmf) {
        this.model = model;
        this.dmmf = dmmf;
        const outputType = dmmf.outputTypeMap[model.name];
        this.outputType = new OutputType(outputType);
        this.mapping = dmmf.mappings.find(m => m.model === model.name);
    }
    get argsTypes() {
        const { mapping, model } = this;
        const argsTypes = [];
        for (const action in dmmf_types_1.DMMF.ModelAction) {
            const fieldName = mapping[action];
            if (!fieldName) {
                continue;
            }
            const field = this.dmmf.getField(fieldName);
            if (!field) {
                throw new Error(`Oops this must not happen. Could not find field ${fieldName} on either Query or Mutation`);
            }
            if (action === 'updateMany' || action === 'deleteMany') {
                argsTypes.push(new MinimalArgsType(field.args, model, action));
            }
            else {
                argsTypes.push(new ArgsType(field.args, model, action));
            }
        }
        argsTypes.push(new ArgsType([], model));
        return argsTypes;
    }
    toJS() {
        return `${new ModelDelegate(this.outputType, this.dmmf).toJS()}`;
    }
    toTS() {
        const { model, outputType } = this;
        if (!outputType) {
            return '';
        }
        const scalarFields = model.fields.filter(f => f.kind !== 'object');
        return `
/**
 * Model ${model.name}
 */

export type ${model.name} = {
${indent_string_1.default(model.fields
            .filter(f => f.kind !== 'object')
            .map(field => new OutputField(field).toTS())
            .join('\n'), tab)}
}

${scalarFields.length > 0
            ? `export type ${utils_1.getScalarsName(model.name)} = ${scalarFields.length > 0
                ? scalarFields.map(f => `'${f.name}'`).join(' | ')
                : ``}
  `
            : ''}

export type ${utils_1.getSelectName(model.name)} = {
${indent_string_1.default(outputType.fields
            .map(f => `${f.name}?: boolean` +
            (f.outputType.kind === 'object'
                ? ` | ${utils_1.getFieldArgName(f, utils_1.Projection.select)}Optional`
                : ''))
            .join('\n'), tab)}
}

export type ${utils_1.getIncludeName(model.name)} = {
${indent_string_1.default(outputType.fields
            .filter(f => f.outputType.kind === 'object')
            .map(f => `${f.name}?: boolean` +
            (f.outputType.kind === 'object'
                ? ` | ${utils_1.getFieldArgName(f, utils_1.Projection.include)}Optional`
                : ''))
            .join('\n'), tab)}
}

${new ModelDefault(model, this.dmmf).toTS()}

${new PayloadType(this.outputType, utils_1.Projection.select).toTS()}

${new PayloadType(this.outputType, utils_1.Projection.include).toTS()}

${new ModelDelegate(this.outputType, this.dmmf).toTS()}

// Custom InputTypes
${this.argsTypes.map(TS).join('\n')}
`;
    }
}
exports.Model = Model;
class Query {
    constructor(dmmf, operation) {
        this.dmmf = dmmf;
        this.operation = operation;
    }
    toTS() {
        const { dmmf, operation } = this;
        const queryName = common_1.capitalize(operation);
        const mappings = dmmf.mappings.map(mapping => ({
            name: mapping.model,
            mapping: Object.entries(mapping).filter(([key]) => utils_1.isQueryAction(key, operation)),
        }));
        const queryType = operation === 'query' ? dmmf.queryType : dmmf.mutationType;
        const outputType = new OutputType(queryType);
        return `\
/**
 * ${queryName}
 */

export type ${queryName}Args = {
${indent_string_1.default(utils_1.flatMap(mappings, ({ name, mapping }) => mapping
            .filter(([action, field]) => field)
            .map(([action, field]) => `${field}?: ${utils_1.getModelArgName(name, utils_1.Projection.select, action)}`)).join('\n'), tab)}
}

${new QueryPayloadType(outputType).toTS()}

${new QueryDelegate(outputType).toTS()}
`;
    }
}
exports.Query = Query;
function getMethodJSDocBody(action, mapping, model) {
    const singular = common_1.capitalize(mapping.model);
    const plural = common_1.capitalize(mapping.plural);
    const firstScalar = model.fields.find(f => f.kind === 'scalar');
    const method = `prisma.${common_1.lowerCase(mapping.model)}.${action}`;
    switch (action) {
        case dmmf_types_1.DMMF.ModelAction.create:
            return `Create a ${singular}.
@param {${utils_1.getModelArgName(model.name, undefined, action)}} args - Arguments to create a ${singular}.
@example
// Create one ${singular}
const user = await ${method}({
  data: {
    // ... data to create a ${singular}
  }
})
`;
        case dmmf_types_1.DMMF.ModelAction.delete:
            return `Delete a ${singular}.
@param {${utils_1.getModelArgName(model.name, undefined, action)}} args - Arguments to delete one ${singular}.
@example
// Delete one ${singular}
const user = await ${method}({
  where: {
    // ... filter to delete one ${singular}
  }
})
`;
        case dmmf_types_1.DMMF.ModelAction.deleteMany:
            return `Delete zero or more ${plural}.
@param {${utils_1.getModelArgName(model.name, undefined, action)}} args - Arguments to filter ${plural} to delete.
@example
// Delete a few ${plural}
const { count } = await ${method}({
  where: {
    // ... provide filter here
  }
})
`;
        case dmmf_types_1.DMMF.ModelAction.findMany: {
            const onlySelect = firstScalar
                ? `\n// Only select the \`${firstScalar.name}\`
const ${common_1.lowerCase(mapping.model)}With${common_1.capitalize(firstScalar.name)}Only = await ${method}({ select: { ${firstScalar.name}: true } })`
                : '';
            return `Find zero or more ${plural}.
@param {${utils_1.getModelArgName(model.name, undefined, action)}=} args - Arguments to filter and select certain fields only.
@example
// Get all ${plural}
const ${mapping.plural} = await ${method}()

// Get first 10 ${plural}
const ${mapping.plural} = await ${method}({ first: 10 })
${onlySelect}
`;
        }
        case dmmf_types_1.DMMF.ModelAction.findOne: {
            return `Find zero or one ${singular}.
@param {${utils_1.getModelArgName(model.name, undefined, action)}} args - Arguments to find a ${singular}
@example
// Get one ${singular}
const ${common_1.lowerCase(mapping.model)} = await ${method}({
  where: {
    // ... provide filter here
  }
})`;
        }
        case dmmf_types_1.DMMF.ModelAction.update:
            return `Update one ${singular}.
@param {${utils_1.getModelArgName(model.name, undefined, action)}} args - Arguments to update one ${singular}.
@example
// Update one ${singular}
const ${common_1.lowerCase(mapping.model)} = await ${method}({
  where: {
    // ... provide filter here
  },
  data: {
    // ... provider data here
  }
})
`;
        case dmmf_types_1.DMMF.ModelAction.updateMany:
            return `Update zero or more ${plural}.
@param {${utils_1.getModelArgName(model.name, undefined, action)}} args - Arguments to update one or more rows.
@example
// Update many ${plural}
const ${common_1.lowerCase(mapping.model)} = await ${method}({
  where: {
    // ... provide filter here
  },
  data: {
    // ... provider data here
  }
})
`;
        case dmmf_types_1.DMMF.ModelAction.upsert:
            return `Create or update one ${singular}.
@param {${utils_1.getModelArgName(model.name, undefined, action)}} args - Arguments to update or create a ${singular}.
@example
// Update or create a ${singular}
const ${common_1.lowerCase(mapping.model)} = await ${method}({
  create: {
    // ... data to create a ${singular}
  },
  update: {
    // ... in case it already exists, update
  },
  where: {
    // ... the filter for the ${singular} we want to update
  }
})`;
    }
}
function getMethodJSDoc(action, mapping, model) {
    return wrapComment(getMethodJSDocBody(action, mapping, model));
}
function wrapComment(str) {
    return `/**\n${str
        .split('\n')
        .map(l => ' * ' + l)
        .join('\n')}\n**/`;
}
class ModelDelegate {
    constructor(outputType, dmmf) {
        this.outputType = outputType;
        this.dmmf = dmmf;
    }
    toJS() {
        const { fields, name } = this.outputType;
        const mapping = this.dmmf.mappings.find(m => m.model === name);
        const model = this.dmmf.datamodel.models.find(m => m.name === name);
        const actions = Object.entries(mapping).filter(([key, value]) => key !== 'model' && key !== 'plural' && key !== 'aggregate' && value);
        // TODO: The following code needs to be split up and is a mess
        return `\
function ${name}Delegate(dmmf, fetcher, errorFormat, measurePerformance) {
  const ${name} = {} 
${indent_string_1.default(actions
            .map(([actionName, fieldName]) => actionName === 'deleteMany' || actionName === 'updateMany'
            ? `${name}.${actionName} = (args) => new ${name}Client(${utils_1.renderInitialClientArgs(actionName, fieldName, mapping)})`
            : `${name}.${actionName} = (args) => ${actionName !== 'findMany' ? `args && args.select ? ` : ''}new ${name}Client(${utils_1.renderInitialClientArgs(actionName, fieldName, mapping)})${actionName !== 'findMany'
                ? ` : new ${name}Client(${utils_1.renderInitialClientArgs(actionName, fieldName, mapping)})`
                : ''}`)
            .join('\n'), tab)}
  ${name}.count = () => new ${name}Client(dmmf, fetcher, 'query', '${mapping.aggregate}', '${mapping.plural}.count', {}, ['count'], errorFormat)
  return ${name}
}

class ${name}Client {
  constructor(_dmmf, _fetcher, _queryType, _rootField, _clientMethod, _args, _dataPath, _errorFormat, _measurePerformance, _isList) {
    this._dmmf = _dmmf;
    this._fetcher = _fetcher;
    this._queryType = _queryType;
    this._rootField = _rootField;
    this._clientMethod = _clientMethod;
    this._args = _args;
    this._dataPath = _dataPath;
    this._errorFormat = _errorFormat;
    this._measurePerformance = _measurePerformance;
    this._isList = _isList;
    if (this._measurePerformance) {
      // Timestamps for performance checks
      this._collectTimestamps = new CollectTimestamps("PrismaClient");
    }
    // @ts-ignore
    if (process.env.NODE_ENV !== 'production' && this._errorFormat !== 'minimal') {
      const error = new Error();
      if (error && error.stack) {
        const stack = error.stack;
        this._callsite = stack;
      }
    }
  }
${indent_string_1.default(fields
            .filter(f => f.outputType.kind === 'object')
            .map(f => {
            return `
${f.name}(args) {
  const prefix = this._dataPath.includes('select') ? 'select' : this._dataPath.includes('include') ? 'include' : 'select'
  const dataPath = [...this._dataPath, prefix, '${f.name}']
  const newArgs = deepSet(this._args, dataPath, args || true)
  this._isList = ${f.outputType.isList}
  return new ${utils_1.getFieldTypeName(f)}Client(this._dmmf, this._fetcher, this._queryType, this._rootField, this._clientMethod, newArgs, dataPath, this._errorFormat, this._measurePerformance, this._isList)
}`;
        })
            .join('\n'), 2)}

  get _document() {
    const { _rootField: rootField } = this
    this._collectTimestamps && this._collectTimestamps.record("Pre-makeDocument")
    const document = makeDocument({
      dmmf: this._dmmf,
      rootField,
      rootTypeName: this._queryType,
      select: this._args
    })
    this._collectTimestamps && this._collectTimestamps.record("Post-makeDocument")
    try {
      this._collectTimestamps && this._collectTimestamps.record("Pre-document.validate")
      document.validate(this._args, false, this._clientMethod, this._errorFormat)
      this._collectTimestamps && this._collectTimestamps.record("Post-document.validate")
    } catch (e) {
      const x = e
      if (this._errorFormat !== 'minimal' && x.render) {
        if (this._callsite) {
          e.message = x.render(this._callsite)
        }
      }
      throw e
    }
    this._collectTimestamps && this._collectTimestamps.record("Pre-transformDocument")
    const transformedDocument = transformDocument(document)
    this._collectTimestamps && this._collectTimestamps.record("Post-transformDocument")
    return transformedDocument
  }

  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then(onfulfilled, onrejected) {
    if (!this._requestPromise){
      this._requestPromise = this._fetcher.request({
        document: this._document,
        dataPath: this._dataPath,
        rootField: this._rootField,
        typeName: '${name}',
        isList: this._isList,
        callsite: this._callsite,
        collectTimestamps: this._collectTimestamps,
        clientMethod: this._clientMethod
      })
    }
    return this._requestPromise.then(onfulfilled, onrejected)
  }

  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch(onrejected) {
    if (!this._requestPromise) {
      this._requestPromise = this._fetcher.request({
        document: this._document,
        dataPath: this._dataPath,
        rootField: this._rootField,
        typeName: '${name}',
        isList: this._isList,
        callsite: this._callsite,
        collectTimestamps: this._collectTimestamps,
        clientMethod: this._clientMethod
      })
    }
    return this._requestPromise.catch(onrejected)
  }

  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally) {
    if (!this._requestPromise) {
      this._requestPromise = this._fetcher.request({
        document: this._document,
        dataPath: this._dataPath,
        rootField: this._rootField,
        typeName: '${name}',
        isList: this._isList,
        callsite: this._callsite,
        collectTimestamps: this._collectTimestamps,
        clientMethod: this._clientMethod
      })
    }
    return this._requestPromise.finally(onfinally)
  }
}

exports.${name}Client = ${name}Client
`;
    }
    toTS() {
        const { fields, name } = this.outputType;
        const mapping = this.dmmf.mappings.find(m => m.model === name);
        const model = this.dmmf.datamodel.models.find(m => m.name === name);
        const actions = Object.entries(mapping).filter(([key, value]) => key !== 'model' && key !== 'plural' && key !== 'aggregate' && value);
        // TODO: The following code needs to be split up and is a mess
        return `\
export interface ${name}Delegate {
${indent_string_1.default(actions
            .map(([actionName]) => `${getMethodJSDoc(actionName, mapping, model)}
${actionName}<T extends ${utils_1.getModelArgName(name, 
        /*projection*/ undefined, actionName)}>(
  args${actionName === dmmf_types_1.DMMF.ModelAction.findMany ? '?' : ''}: Subset<T, ${utils_1.getModelArgName(name, undefined, actionName)}>
): ${utils_1.getSelectReturnType({ name, actionName, projection: utils_1.Projection.select })}`)
            .join('\n'), tab)}
  /**
   * 
   */
  count(): Promise<number>
}

export declare class ${name}Client<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  private _collectTimestamps?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';
${indent_string_1.default(fields
            .filter(f => f.outputType.kind === 'object')
            .map(f => {
            const fieldTypeName = f.outputType.type.name;
            return `
${f.name}<T extends ${utils_1.getFieldArgName(f)} = {}>(args?: Subset<T, ${utils_1.getFieldArgName(f)}>): ${utils_1.getSelectReturnType({
                name: fieldTypeName,
                actionName: f.outputType.isList
                    ? dmmf_types_1.DMMF.ModelAction.findMany
                    : dmmf_types_1.DMMF.ModelAction.findOne,
                hideCondition: false,
                isField: true,
                renderPromise: true,
                fieldName: f.name,
                projection: utils_1.Projection.select,
            })};`;
        })
            .join('\n'), 2)}

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}`;
    }
}
exports.ModelDelegate = ModelDelegate;
class QueryDelegate {
    constructor(outputType) {
        this.outputType = outputType;
    }
    toTS() {
        const name = this.outputType.name;
        return `\
interface ${name}Delegate {
  <T extends ${name}Args>(args: Subset<T,${name}Args>): Promise<${utils_1.getPayloadName(name, utils_1.Projection.select)}<T>>
}
function ${name}Delegate(dmmf: DMMFClass, fetcher: PrismaClientFetcher): ${name}Delegate {
  const ${name} = <T extends ${name}Args>(args: ${name}Args) => new ${name}Client<T>(dmmf, fetcher, args, [])
  return ${name}
}

class ${name}Client<T extends ${name}Args, U = ${utils_1.getPayloadName(name, utils_1.Projection.select)}<T>> implements Promise<U> {
  constructor(private readonly dmmf: DMMFClass, private readonly fetcher: PrismaClientFetcher, private readonly args: ${name}Args, private readonly _dataPath: []) {}

  readonly [Symbol.toStringTag]: 'Promise'

  protected get document() {
    const rootField = Object.keys(this.args)[0]
    const document = makeDocument({
      dmmf: this.dmmf,
      rootField,
      rootTypeName: 'query',
      // @ts-ignore
      select: this.args[rootField]
    })
    // @ts-ignore
    document.validate(this.args[rootField], true)
    return document
  }

  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = U, TResult2 = never>(
    onfulfilled?: ((value: U) => TResult1 | Promise<TResult1>) | undefined | null,
    onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null,
  ): Promise<TResult1 | TResult2> {
    return this.fetcher.request<U>({
      document: this.document,
      dataPath: this._dataPath,
      typeName: '${name}'
    }).then(onfulfilled, onrejected)
  }

  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(
    onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null,
  ): Promise<U | TResult> {
    return this.fetcher.request<U>({
      document: this.document,
      dataPath: this._dataPath,
      typeName: '${name}'
    }).catch(onrejected)
  }
}
    `;
    }
}
exports.QueryDelegate = QueryDelegate;
class InputField {
    constructor(field, prefixFilter = false) {
        this.field = field;
        this.prefixFilter = prefixFilter;
    }
    toTS() {
        const { field } = this;
        let fieldType;
        let hasNull = false;
        if (Array.isArray(field.inputType)) {
            fieldType = utils_1.flatMap(field.inputType, t => {
                const type = typeof t.type === 'string'
                    ? common_1.GraphQLScalarToJSTypeTable[t.type] || t.type
                    : this.prefixFilter
                        ? `Base${t.type.name}`
                        : t.type.name;
                if (type === 'null') {
                    hasNull = true;
                }
                return type;
            }).join(' | ');
        }
        const fieldInputType = field.inputType[0];
        const optionalStr = fieldInputType.isRequired ? '' : '?';
        if (fieldInputType.isList) {
            fieldType = `Enumerable<${fieldType}>`;
        }
        const nullableStr = !fieldInputType.isRequired && !hasNull ? ' | null' : '';
        const jsdoc = field.comment ? wrapComment(field.comment) + '\n' : '';
        return `${jsdoc}${field.name}${optionalStr}: ${fieldType}${nullableStr}`;
    }
}
exports.InputField = InputField;
class OutputField {
    constructor(field) {
        this.field = field;
    }
    toTS() {
        const { field } = this;
        // ENUMTODO
        let fieldType = typeof field.type === 'string'
            ? common_1.GraphQLScalarToJSTypeTable[field.type] || field.type
            : field.type[0].name;
        if (Array.isArray(fieldType)) {
            fieldType = fieldType[0];
        }
        const arrayStr = field.isList ? `[]` : '';
        const nullableStr = !field.isRequired && !field.isList ? ' | null' : '';
        return `${field.name}: ${fieldType}${arrayStr}${nullableStr}`;
    }
}
exports.OutputField = OutputField;
class OutputType {
    constructor(type) {
        this.type = type;
        this.name = type.name;
        this.fields = type.fields;
    }
    toTS() {
        const { type } = this;
        return `
export type ${type.name} = {
${indent_string_1.default(type.fields
            .map(field => new OutputField({ ...field, ...field.outputType }).toTS())
            .join('\n'), tab)}
}`;
    }
}
exports.OutputType = OutputType;
class MinimalArgsType {
    constructor(args, model, action) {
        this.args = args;
        this.model = model;
        this.action = action;
    }
    toTS() {
        const { action, args } = this;
        const { name } = this.model;
        return `
/**
 * ${name} ${action ? action : 'without action'}
 */
export type ${utils_1.getModelArgName(name, undefined, action)} = {
${indent_string_1.default(args.map(arg => new InputField(arg).toTS()).join('\n'), tab)}
}
`;
    }
}
exports.MinimalArgsType = MinimalArgsType;
const topLevelArgsJsDocs = {
    findOne: {
        where: (singular, plural) => `Filter, which ${singular} to fetch.`,
    },
    findMany: {
        where: (singular, plural) => `Filter, which ${plural} to fetch.`,
        orderBy: (singular, plural) => `Determine the order of the ${plural} to fetch.`,
        skip: (singular, plural) => `Skip the first \`n\` ${plural}.`,
        after: (singular, plural) => `Get all ${plural} that come after the ${singular} you provide with the current order.`,
        before: (singular, plural) => `Get all ${plural} that come before the ${singular} you provide with the current order.`,
        first: (singular, plural) => `Get the first \`n\` ${plural}.`,
        last: (singular, plural) => `Get the last \`n\` ${plural}.`,
    },
    create: {
        data: (singular, plural) => `The data needed to create a ${singular}.`,
    },
    update: {
        data: (singular, plural) => `The data needed to update a ${singular}.`,
        where: (singular, plural) => `Choose, which ${singular} to update.`,
    },
    upsert: {
        where: (singular, plural) => `The filter to search for the ${singular} to update in case it exists.`,
        create: (singular, plural) => `In case the ${singular} found by the \`where\` argument doesn't exist, create a new ${singular} with this data.`,
        update: (singular, plural) => `In case the ${singular} was found with the provided \`where\` argument, update it with this data.`,
    },
    delete: {
        where: (singular, plural) => `Filter which ${singular} to delete.`,
    },
};
class ArgsType {
    constructor(args, model, action) {
        this.args = args;
        this.model = model;
        this.action = action;
    }
    toTS() {
        const { action, args } = this;
        const { name } = this.model;
        const singular = name;
        const plural = pluralize_1.default(name);
        args.forEach(arg => {
            if (action && topLevelArgsJsDocs[action][arg.name]) {
                const comment = topLevelArgsJsDocs[action][arg.name](singular, plural);
                arg.comment = comment;
            }
        });
        const bothArgsOptional = [
            {
                name: 'select',
                inputType: [
                    {
                        type: utils_1.getSelectName(name),
                        kind: 'object',
                        isList: false,
                        isRequired: false,
                    },
                ],
                comment: `Select specific fields to fetch from the ${name}`,
            },
            {
                name: 'include',
                inputType: [
                    {
                        type: utils_1.getIncludeName(name),
                        kind: 'object',
                        isList: false,
                        isRequired: false,
                    },
                ],
                comment: `Choose, which related nodes to fetch as well.`,
            },
            ...args,
        ];
        const bothArgsRequired = [
            {
                name: 'select',
                inputType: [
                    {
                        type: utils_1.getSelectName(name),
                        kind: 'object',
                        isList: false,
                        isRequired: true,
                    },
                ],
                comment: `Select specific fields to fetch from the ${name}`,
            },
            {
                name: 'include',
                inputType: [
                    {
                        type: utils_1.getIncludeName(name),
                        kind: 'object',
                        isList: false,
                        isRequired: true,
                    },
                ],
                comment: `Choose, which related nodes to fetch as well.`,
            },
            ...args,
        ];
        const selectArgsRequired = [
            {
                name: 'select',
                inputType: [
                    {
                        type: utils_1.getSelectName(name),
                        kind: 'object',
                        isList: false,
                        isRequired: true,
                    },
                ],
                comment: `Select specific fields to fetch from the ${name}`,
            },
            ...args,
        ];
        const selectArgsOptional = [
            {
                name: 'select',
                inputType: [
                    {
                        type: utils_1.getSelectName(name),
                        kind: 'object',
                        isList: false,
                        isRequired: false,
                    },
                ],
                comment: `Select specific fields to fetch from the ${name}`,
            },
            ...args,
        ];
        const includeArgsRequired = [
            {
                name: 'include',
                inputType: [
                    {
                        type: utils_1.getIncludeName(name),
                        kind: 'object',
                        isList: false,
                        isRequired: true,
                    },
                ],
                comment: `Choose, which related nodes to fetch as well.`,
            },
            ...args,
        ];
        const includeArgsOptional = [
            {
                name: 'include',
                inputType: [
                    {
                        type: utils_1.getIncludeName(name),
                        kind: 'object',
                        isList: false,
                        isRequired: false,
                    },
                ],
                comment: `Choose, which related nodes to fetch as well.`,
            },
            ...args,
        ];
        return `
/**
 * ${name} ${action ? action : 'without action'}
 */
export type ${utils_1.getModelArgName(name, undefined, action)} = {
${indent_string_1.default(bothArgsOptional.map(arg => new InputField(arg).toTS()).join('\n'), tab)}
}

export type ${utils_1.getModelArgName(name, undefined, action)}Required = {
${indent_string_1.default(bothArgsRequired.map(arg => new InputField(arg).toTS()).join('\n'), tab)}
}

export type ${utils_1.getModelArgName(name, utils_1.Projection.select, action)} = {
${indent_string_1.default(selectArgsRequired.map(arg => new InputField(arg).toTS()).join('\n'), tab)}
}

export type ${utils_1.getModelArgName(name, utils_1.Projection.select, action)}Optional = {
${indent_string_1.default(selectArgsOptional.map(arg => new InputField(arg).toTS()).join('\n'), tab)}
}

export type ${utils_1.getModelArgName(name, utils_1.Projection.include, action)} = {
${indent_string_1.default(includeArgsRequired.map(arg => new InputField(arg).toTS()).join('\n'), tab)}
}

export type ${utils_1.getModelArgName(name, utils_1.Projection.include, action)}Optional = {
${indent_string_1.default(includeArgsOptional.map(arg => new InputField(arg).toTS()).join('\n'), tab)}
}

export type Extract${utils_1.getModelArgName(name, utils_1.Projection.select, action)}<S extends undefined | boolean | ${utils_1.getModelArgName(name, utils_1.Projection.select, action)}Optional> = S extends undefined
  ? false
  : S extends boolean
  ? S
  : S extends ${utils_1.getModelArgName(name, utils_1.Projection.select, action)}
  ? S['select']
  : true

export type Extract${utils_1.getModelArgName(name, utils_1.Projection.include, action)}<S extends undefined | boolean | ${utils_1.getModelArgName(name, utils_1.Projection.include, action)}Optional> = S extends undefined
  ? false
  : S extends boolean
  ? S
  : S extends ${utils_1.getModelArgName(name, utils_1.Projection.include, action)}
  ? S['include']
  : true

`;
    }
}
exports.ArgsType = ArgsType;
class InputType {
    constructor(type) {
        this.type = type;
    }
    toTS() {
        const { type } = this;
        const fields = uniqueBy_1.uniqueBy(type.fields, f => f.name);
        // TO DISCUSS: Should we rely on TypeScript's error messages?
        const body = `{
${indent_string_1.default(fields
            .map(arg => new InputField(arg /*, type.atLeastOne && !type.atMostOne*/).toTS())
            .join('\n'), tab)}
}`;
        return `
export type ${type.name} = ${body}`;
    }
}
exports.InputType = InputType;
class Enum {
    constructor(type) {
        this.type = type;
    }
    toJS() {
        const { type } = this;
        return `exports.${type.name} = makeEnum({
${indent_string_1.default(type.values.map(v => `${v}: '${v}'`).join(',\n'), tab)}
});`;
    }
    toTS() {
        const { type } = this;
        return `export declare const ${type.name}: {
${indent_string_1.default(type.values.map(v => `${v}: '${v}'`).join(',\n'), tab)}
};

export declare type ${type.name} = (typeof ${type.name})[keyof typeof ${type.name}]\n`;
    }
}
exports.Enum = Enum;
//# sourceMappingURL=TSClient.js.map
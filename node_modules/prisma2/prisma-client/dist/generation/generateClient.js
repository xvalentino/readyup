"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const copy_1 = __importDefault(require("@apexearth/copy"));
const debug_1 = __importDefault(require("debug"));
const fs_1 = __importDefault(require("fs"));
const make_dir_1 = __importDefault(require("make-dir"));
const path_1 = __importDefault(require("path"));
const chalk_1 = __importDefault(require("chalk"));
const util_1 = require("util");
const getDMMF_1 = require("./getDMMF");
const resolveDatasources_1 = require("../utils/resolveDatasources");
const extractSqliteSources_1 = require("./extractSqliteSources");
const TSClient_1 = require("./TSClient");
const engineCommands_1 = require("@prisma/sdk/dist/engineCommands");
const debug = debug_1.default('generateClient');
debug.log = console.log.bind(console);
const remove = util_1.promisify(fs_1.default.unlink);
const writeFile = util_1.promisify(fs_1.default.writeFile);
const exists = util_1.promisify(fs_1.default.exists);
const copyFile = util_1.promisify(fs_1.default.copyFile);
const stat = util_1.promisify(fs_1.default.stat);
async function buildClient({ datamodel, schemaDir = process.cwd(), transpile = false, runtimePath = './runtime', browser = false, binaryPaths, outputDir, generator, version, dmmf, datasources, }) {
    const document = getDMMF_1.getPrismaClientDMMF(dmmf);
    const client = new TSClient_1.TSClient({
        document,
        runtimePath,
        browser,
        datasources: resolveDatasources_1.resolveDatasources(datasources, schemaDir, outputDir),
        sqliteDatasourceOverrides: extractSqliteSources_1.extractSqliteSources(datamodel, schemaDir, outputDir),
        generator,
        platforms: Object.keys(binaryPaths.queryEngine),
        version,
        schemaDir,
        outputDir,
    });
    const fileMap = {
        'index.d.ts': TSClient_1.TS(client),
        'index.js': TSClient_1.JS(client),
    };
    return {
        fileMap,
        prismaClientDmmf: document,
    };
}
exports.buildClient = buildClient;
async function generateClient({ datamodel, datamodelPath, schemaDir = datamodelPath ? path_1.default.dirname(datamodelPath) : process.cwd(), outputDir, transpile, runtimePath, browser, version = 'latest', generator, dmmf, datasources, binaryPaths, testMode, copyRuntime, }) {
    runtimePath = runtimePath || './runtime';
    const { prismaClientDmmf, fileMap } = await buildClient({
        datamodel,
        datamodelPath,
        schemaDir,
        transpile,
        runtimePath,
        browser,
        outputDir,
        generator,
        version,
        dmmf,
        datasources,
        binaryPaths,
    });
    const denylistsErrors = validateDmmfAgainstDenylists(prismaClientDmmf);
    if (denylistsErrors) {
        console.error(`${chalk_1.default.redBright.bold('Error: ')}The schema at "${datamodelPath}" contains reserved keywords.\n       Rename the following items:`);
        for (const error of denylistsErrors) {
            console.error('         - ' + error.message);
        }
        process.exit(1);
    }
    debug(`makeDir: ${outputDir}`);
    await make_dir_1.default(path_1.default.join(outputDir, 'runtime'));
    await Promise.all(Object.entries(fileMap).map(async ([fileName, file]) => {
        const filePath = path_1.default.join(outputDir, fileName);
        // The deletion of the file is necessary, so VSCode
        // picks up the changes.
        if (await exists(filePath)) {
            await remove(filePath);
        }
        await writeFile(filePath, file);
    }));
    const inputDir = testMode
        ? eval(`require('path').join(__dirname, '../../runtime')`) // tslint:disable-line
        : eval(`require('path').join(__dirname, '../runtime')`); // tslint:disable-line
    // if users use a custom output dir
    if (copyRuntime ||
        !path_1.default.resolve(outputDir).endsWith(`@prisma${path_1.default.sep}client`)) {
        // TODO: Windows, / is not working here...
        const copyTarget = path_1.default.join(outputDir, '/runtime');
        debug({ copyRuntime, outputDir, copyTarget, inputDir });
        if (inputDir !== copyTarget) {
            await copy_1.default({
                from: inputDir,
                to: copyTarget,
                recursive: true,
                parallelJobs: process.platform === 'win32' ? 1 : 20,
                overwrite: true,
            });
        }
    }
    if (!binaryPaths.queryEngine) {
        throw new Error(`Prisma Client needs \`queryEngine\` in the \`binaryPaths\` object.`);
    }
    if (transpile) {
        for (const filePath of Object.values(binaryPaths.queryEngine)) {
            const fileName = path_1.default.basename(filePath);
            const target = path_1.default.join(outputDir, 'runtime', fileName);
            const before = Date.now();
            const [sourceFileSize, targetFileSize] = await Promise.all([
                fileSize(filePath),
                fileSize(target),
            ]);
            // If the target doesn't exist yet, copy it
            if (!targetFileSize) {
                debug(`Copying ${filePath} to ${target}`);
                await copyFile(filePath, target);
                continue;
            }
            // If target !== source size, they're definitely different, copy it
            if (targetFileSize &&
                sourceFileSize &&
                targetFileSize !== sourceFileSize) {
                debug(`Copying ${filePath} to ${target}`);
                await copyFile(filePath, target);
                continue;
            }
            // They must have an equal size now, let's check for the hash
            const [sourceVersion, targetVersion] = await Promise.all([
                engineCommands_1.getVersion(filePath).catch(() => null),
                engineCommands_1.getVersion(target).catch(() => null),
            ]);
            const after = Date.now();
            if (sourceVersion && targetVersion && sourceVersion === targetVersion) {
                debug(`Getting hashes took ${after - before}ms`);
                debug(`Skipping ${filePath} to ${target} as both files have md5 hash ${sourceVersion}`);
            }
            else {
                debug(`Copying ${filePath} to ${target}`);
                await copyFile(filePath, target);
            }
        }
    }
    const datamodelTargetPath = path_1.default.join(outputDir, 'schema.prisma');
    if (datamodelPath !== datamodelTargetPath) {
        await copyFile(datamodelPath, datamodelTargetPath);
    }
    if (transpile) {
        await writeFile(path_1.default.join(outputDir, 'runtime/index.d.ts'), backup);
    }
    return { prismaClientDmmf, fileMap };
}
exports.generateClient = generateClient;
const backup = `export { DMMF } from './dmmf-types'
// export { DMMFClass } from './dmmf'
// export { deepGet, deepSet } from './utils/deep-set'
// export { makeDocument, transformDocument } from './query'

export declare var Engine: any
export declare type Engine = any

// export declare var DMMF: any
// export declare type DMMF = any

export declare var DMMFClass: any
export declare type DMMFClass = any

export declare var deepGet: any
export declare type deepGet = any

export declare var chalk: any
export declare type chalk = any

export declare var deepSet: any
export declare type deepSet = any

export declare var makeDocument: any
export declare type makeDocument = any

export declare var transformDocument: any
export declare type transformDocument = any

export declare var debug: any
export declare type debug = any

export declare var debugLib: any
export declare type debugLib = any

export declare var InternalDatasource: any
export declare type InternalDatasource = any

export declare var Datasource: any
export declare type Datasource = any

export declare var printDatasources: any
export declare type printDatasources = any

export declare var printStack: any
export declare type printStack = any

export declare var mergeBy: any
export declare type mergeBy = any

export declare var unpack: any
export declare type unpack = any

export declare var getDMMF: any
export declare type getDMMF = any

export declare var stripAnsi: any
export declare type stripAnsi = any

export declare var parseDotenv: any
export declare type parseDotenv = any

export declare class PrismaClientKnownRequestError extends Error {
  code: string;
  meta?: Object;
  constructor(message: string, code: string, meta?: any);
}

export declare class PrismaClientUnknownRequestError extends Error {
  constructor(message: string);
}

export declare class PrismaClientRustPanicError extends Error {
    constructor(message: string);
}

export declare class PrismaClientInitializationError extends Error {
    constructor(message: string);
}

export declare class PrismaClientValidationError extends Error {
    constructor(message: string);
}
`;
async function fileSize(name) {
    try {
        const statResult = await stat(name);
        return statResult.size;
    }
    catch (e) {
        return null;
    }
}
function validateDmmfAgainstDenylists(prismaClientDmmf) {
    const errorArray = [];
    const denylists = {
        models: [
            'dmmf',
            'PromiseType',
            'PromiseReturnType',
            'Enumerable',
            'MergeTruthyValues',
            'CleanupNever',
            'Subset',
            'AtLeastOne',
            'atMostOne',
            'OnlyOne',
            'StringFilter',
            'IDFilter',
            'FloatFilter',
            'IntFilter',
            'BooleanFilter',
            'DateTimeFilter',
            'NullableStringFilter',
            'NullableIDFilter',
            'NullableFloatFilter',
            'NullableIntFilter',
            'NullableBooleanFilter',
            'NullableDateTimeFilter',
            'PrismaClientFetcher',
            'PrismaClient',
            'Engine',
            'BatchPayload',
            'Datasources',
            'ErrorFormat',
            'Hooks',
            'LogLevel',
            'LogDefinition',
            'GetLogType',
            'GetEvents',
            'QueryEvent',
            'LogEvent',
            'ModelDelegate',
            'QueryDelegate',
            'missingArg',
            'ArgError',
            'InvalidFieldError',
            'InvalidFieldNameError',
            'InvalidFieldTypeError',
            'EmptySelectError',
            'NoTrueSelectError',
            'IncludeAndSelectError',
            'EmptyIncludeError',
            'InvalidArgError',
            'InvalidArgNameError',
            'MissingArgError',
            'InvalidArgTypeError',
            'AtLeastOneError',
            'AtMostOneError',
            'PrismaClientRequestError',
            'PrismaClientOptions',
            'PrismaClientKnownRequestError',
            'PrismaClientUnknownRequestError',
            'PrismaClientInitializationError',
            'PrismaClientRustPanicError',
        ],
        fields: ['AND', 'OR', 'NOT'],
        dynamic: [],
    };
    for (const m of prismaClientDmmf.datamodel.models) {
        denylists.dynamic.push(...[
            `${m.name}Select`,
            `${m.name}Include`,
            `${m.name}Default`,
            `${m.name}GetSelectPayload`,
            `${m.name}GetIncludePayload`,
            `${m.name}Client`,
            `${m.name}Delegate`,
            `${m.name}Args`,
            `${m.name}ArgsFilter`,
            `${m.name}ArgsRequired`,
            `${m.name}SelectArgs`,
            `${m.name}SelectArgsOptional`,
            `${m.name}IncludeArgs`,
            `${m.name}IncludeArgsOptional`,
            `Extract${m.name}SelectCreateArgs`,
            `Extract${m.name}IncludeCreateArgs`,
            `${m.name}WhereInput`,
            `${m.name}WhereUniqueInput`,
            `${m.name}CreateInput`,
            `${m.name}UpdateInput`,
            `${m.name}UpdateManyMutationInput`,
            `${m.name}OrderByInput`,
            `${m.name}CreateArgs`,
            `${m.name}CreateArgsRequired`,
            `${m.name}SelectCreateArgs`,
            `${m.name}IncludeCreateArgs`,
            `Extract${m.name}SelectCreateArgs`,
            `Extract${m.name}IncludeCreateArgs`,
            `${m.name}SelectCreateArgsOptional`,
            `${m.name}IncludeCreateArgsOptional`,
            `${m.name}UpsertArgs`,
            `${m.name}UpsertArgsRequired`,
            `${m.name}SelectUpsertArgs`,
            `${m.name}IncludeUpsertArgs`,
            `Extract${m.name}SelectUpsertArgs`,
            `Extract${m.name}IncludeUpsertArgs`,
            `${m.name}SelectUpsertArgsOptional`,
            `${m.name}IncludeUpsertArgsOptional`,
            `${m.name}UpdateArgs`,
            `${m.name}UpdateArgsRequired`,
            `${m.name}SelectUpdateArgs`,
            `${m.name}IncludeUpdateArgs`,
            `${m.name}UpdateManyArgs`,
            `Extract${m.name}SelectUpdateArgs`,
            `Extract${m.name}IncludeUpdateArgs`,
            `${m.name}SelectUpdateArgsOptional`,
            `${m.name}IncludeUpdateArgsOptional`,
            `${m.name}DeleteArgs`,
            `${m.name}DeleteArgsRequired`,
            `${m.name}SelectDeleteArgs`,
            `${m.name}IncludeDeleteArgs`,
            `${m.name}DeleteManyArgs`,
            `Extract${m.name}SelectDeleteArgs`,
            `Extract${m.name}IncludeDeleteArgs`,
            `${m.name}SelectDeleteArgsOptional`,
            `${m.name}IncludeDeleteArgsOptional`,
            `FindOne${m.name}Args`,
            `FindOne${m.name}ArgsRequired`,
            `FindOne${m.name}SelectArgs`,
            `FindOne${m.name}IncludeArgs`,
            `FindOne${m.name}SelectArgsOptional`,
            `FindOne${m.name}IncludeArgsOptional`,
            `ExtractFindOne${m.name}SelectArgs`,
            `ExtractFindOne${m.name}IncludeArgs`,
            `FindMany${m.name}Args`,
            `FindMany${m.name}ArgsRequired`,
            `FindMany${m.name}IncludeArgs`,
            `FindMany${m.name}SelectArgs`,
            `FindMany${m.name}SelectArgsOptional`,
            `FindMany${m.name}IncludeArgsOptional`,
            `ExtractFindMany${m.name}SelectArgs`,
            `ExtractFindMany${m.name}IncludeArgs`,
        ]);
    }
    if (prismaClientDmmf.datamodel.enums) {
        for (const it of prismaClientDmmf.datamodel.enums) {
            if (denylists.models.includes(it.name) ||
                denylists.fields.includes(it.name) ||
                denylists.dynamic.includes(it.name)) {
                errorArray.push(Error(`"enum ${it.name}"`));
            }
        }
    }
    if (prismaClientDmmf.datamodel.enums) {
        for (const it of prismaClientDmmf.datamodel.models) {
            if (denylists.models.includes(it.name) ||
                denylists.fields.includes(it.name)) {
                errorArray.push(Error(`"model ${it.name}"`));
            }
        }
    }
    return errorArray.length > 0 ? errorArray : null;
}
//# sourceMappingURL=generateClient.js.map